class ServiceWorkerManager { constructor() { this.swPath = '/sw.js'; this.isSupported = 'serviceWorker' in navigator; } async init() { if (!this.isSupported) { console.log('Service Worker: Not supported in this browser'); return; } try { await this.register(); this.setupEventListeners(); this.checkForUpdates(); } catch (error) { console.error('Service Worker: Registration failed:', error); } } async register() { try { const registration = await navigator.serviceWorker.register(this.swPath); console.log('Service Worker: Registered successfully', registration); if (registration.installing) { console.log('Service Worker: Installing...'); this.trackInstallProgress(registration.installing); } else if (registration.waiting) { console.log('Service Worker: Waiting to activate...'); this.showUpdateAvailable(); } else if (registration.active) { console.log('Service Worker: Active and running'); } return registration; } catch (error) { console.error('Service Worker: Registration failed:', error); throw error; } } trackInstallProgress(worker) { worker.addEventListener('statechange', () => { console.log('Service Worker: State changed to', worker.state); if (worker.state === 'installed') { if (navigator.serviceWorker.controller) { this.showUpdateAvailable(); } else { this.showInstallSuccess(); } } }); } setupEventListeners() { navigator.serviceWorker.addEventListener('controllerchange', () => { console.log('Service Worker: Controller changed, reloading page'); window.location.reload(); }); navigator.serviceWorker.addEventListener('message', event => { this.handleServiceWorkerMessage(event.data); }); document.addEventListener('visibilitychange', () => { if (!document.hidden) { this.checkForUpdates(); } }); } async checkForUpdates() { try { const registration = await navigator.serviceWorker.getRegistration(); if (registration) { await registration.update(); } } catch (error) { console.error('Service Worker: Update check failed:', error); } } handleServiceWorkerMessage(data) { switch (data.type) { case 'CACHE_UPDATED': console.log('Service Worker: Cache updated'); break; case 'OFFLINE_READY': this.showOfflineReady(); break; default: console.log('Service Worker: Message received:', data); } } showInstallSuccess() { this.showNotification('App installed successfully! You can now use it offline.', 'success'); } showUpdateAvailable() { this.showNotification( 'A new version is available! Refresh to update.', 'info', { action: 'Refresh', callback: () => window.location.reload() } ); } showOfflineReady() { this.showNotification('App is ready to work offline!', 'success'); } showNotification(message, type = 'info', action = null) { const notification = document.createElement('div'); notification.className = `sw-notification sw-notification-${type}`; notification.innerHTML = ` <div class="sw-notification-content"> <span class="sw-notification-message">${message}</span> ${action ? `<button class="sw-notification-action">${action.action}</button>` : ''} <button class="sw-notification-close" aria-label="Close notification">Ã—</button> </div> `; this.addNotificationStyles(); const closeBtn = notification.querySelector('.sw-notification-close'); closeBtn.addEventListener('click', () => { notification.remove(); }); if (action) { const actionBtn = notification.querySelector('.sw-notification-action'); actionBtn.addEventListener('click', () => { action.callback(); notification.remove(); }); } setTimeout(() => { if (notification.parentNode) { notification.remove(); } }, 5000); document.body.appendChild(notification); requestAnimationFrame(() => { notification.classList.add('sw-notification-show'); }); } addNotificationStyles() { if (document.getElementById('sw-notification-styles')) { return; } const styles = document.createElement('style'); styles.id = 'sw-notification-styles'; styles.textContent = ` .sw-notification { position: fixed; top: 20px; right: 20px; max-width: 400px; background: white; border-radius: 8px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15); z-index: 10000; transform: translateX(100%); transition: transform 0.3s ease-in-out; border-left: 4px solid #2563eb; } .sw-notification-show { transform: translateX(0); } .sw-notification-success { border-left-color: #10b981; } .sw-notification-info { border-left-color: #3b82f6; } .sw-notification-content { padding: 16px; display: flex; align-items: center; gap: 12px; } .sw-notification-message { flex: 1; font-size: 14px; color: #374151; line-height: 1.4; } .sw-notification-action { background: #2563eb; color: white; border: none; padding: 6px 12px; border-radius: 4px; font-size: 12px; font-weight: 500; cursor: pointer; transition: background-color 0.2s; } .sw-notification-action:hover { background: #1d4ed8; } .sw-notification-close { background: none; border: none; font-size: 18px; color: #9ca3af; cursor: pointer; padding: 0; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; transition: color 0.2s; } .sw-notification-close:hover { color: #374151; } @media (max-width: 480px) { .sw-notification { left: 20px; right: 20px; max-width: none; } } `; document.head.appendChild(styles); } sendPerformanceMark(mark) { if (navigator.serviceWorker.controller) { navigator.serviceWorker.controller.postMessage({ type: 'PERFORMANCE_MARK', mark: mark }); } } async clearCache() { try { const cacheNames = await caches.keys(); await Promise.all( cacheNames.map(cacheName => caches.delete(cacheName)) ); console.log('Service Worker: All caches cleared'); } catch (error) { console.error('Service Worker: Error clearing cache:', error); } } async getCacheInfo() { try { const cacheNames = await caches.keys(); const cacheInfo = {}; for (const cacheName of cacheNames) { const cache = await caches.open(cacheName); const keys = await cache.keys(); cacheInfo[cacheName] = keys.length; } return cacheInfo; } catch (error) { console.error('Service Worker: Error getting cache info:', error); return {}; } } } document.addEventListener('DOMContentLoaded', () => { const swManager = new ServiceWorkerManager(); swManager.init(); window.swManager = swManager; }); if (typeof module !== 'undefined' && module.exports) { module.exports = ServiceWorkerManager; }